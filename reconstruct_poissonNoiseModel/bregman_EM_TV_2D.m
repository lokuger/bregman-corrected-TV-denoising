function u = bregman_EM_TV_2D(f, K, N1, N2, mu, omega, delta, tau, maxBregIts, maxEMIts, tol)
% function implements bregman-EM-TV scheme for reconstructing 2D images
% from signals generated by a Poisson process. Algorithm as in 
% 'Bregman-EM-TV Methods with Application to Optical Nanoscopy', Sawatzky 
% et al. 2009, Lecture Notes in Computer Science
%
% Idea of the algorithm is to bregmanize the EM-TV scheme. This leads to
% an alternating EM-TV denoising step and a weighted, modified ROF model.
%
% Input:    g           -   noisy image/2D signal
%           K           -   forward operator from the inv problem Ku = g
%           mu          -   regularization parameter
%           omega       -   damping parameter
%           delta       -   noise level. needed for disc. principle stop crit
%           tau         -   scaling of delta disc princ
%           maxBregIts  -   maximum number outer bregman iterations
%           maxEMIts    -   maximum number inner EM iterations
%           tol         -   error tolerance in EM iteration scheme
% Output:   u           -   solution of the ROF model

fprintf('Starting Bregman-EM-TV algorithm!\n')
fprintf('Running until KL(f, K*u_l) < delta*tau = %4g\n',delta*tau);

[M1,M2] = size(f);
f = reshape(f, M1*M2, 1);

l = 0;
u = mean(f,'all')*ones(N1, N2);
v = zeros(N1, N2);
K1 = reshape(K'*ones(M1*M2, 1), N1, N2);
stopBregConv = kullback_leibler(f, K*u(:)) < tau*delta;
stopBregIter = false;
fprintf('%1s\t|\t%12s\t|\t%12s\n','l','KL(f, K*u_l)','||v_l||_2');
while ~stopBregConv && ~stopBregIter
    % inner EM iteration
    k = 0;
    stopEMiter = false;
    stopEMconv = false; optk = Inf; uoptk = Inf; poptk = Inf; p = zeros(N1, N2);
    while ~stopEMiter && ~ stopEMconv
        % for details of this inner loop see EM_TV_1D.m
        uK1 = u./K1;
        ukhalf = reshape(uK1(:) .* (K' * (f./max(K*u(:),1))), N1, N2);			% EM step
        ukhalf_damp = omega * (ukhalf + v.*u) + (1-omega)*u;                    % damping step
        [unew,pnew] = mod_ROF_weighted_2D(ukhalf_damp, uK1, omega*mu);			% TV step

        k = k+1;
        optk = weightedL2Norm(K1 - reshape(K'*(f./max(K*unew(:),1)), N1, N2) + mu*pnew, unew);
        uoptk = weightedL2Norm(K1.*(unew - u)./max(mu*u,1), unew);
        poptk = weightedL2Norm(mu*(pnew - p), unew);
		
		stopEMconv = optk < tol && uoptk < tol && poptk < tol;
        stopEMiter = (k == maxEMIts);
    
        u = unew;
        p = pnew;
    end
    if stopEMconv
        fprintf(['\t\t>>> Inner EM-iteration converged after %d iterations at\n' ...
            '\t\t>>> opt_k = %.4g\tu_opt_k = %.4g\tp_opt_k = %.4g\n'],k,optk,uoptk,poptk);
    else
        fprintf(['\t\t>>> Inner EM iteration failed, aborted after %d iterations at\n' ...
            '\t\t>>> opt_k = %.4g\tu_opt_k = %.4g\tp_opt_k = %.4g\n'],k,optk,uoptk,poptk);
    end

    % Bregman: update noise/dual component by which we shift in the mod ROF
    v = v - (ones(N1,N2) - 1./K1 .* reshape(K'*(f./max(K*u(:),1)), N1, N2));

    % update for next iteration and print in command line
    l = l+1;
    fprintf('%1d\t|\t%12.4g\t|\t%12.4g\n',l,kullback_leibler(f, K*u(:)),sum(v.*v,'all'));
    stopBregConv = kullback_leibler(f, K*u(:)) < tau*delta;
    stopBregIter = l == maxBregIts;
end
end

function r = weightedL2Norm(u,w)
% a weighted (squared) norm used only for the stopping criteria. See the paper, eq.
% (35) - (37)
% u is the vector whose norm is computed
% w is a weight vector
r = sqrt(sum(u.^2.*w,'all'));
end